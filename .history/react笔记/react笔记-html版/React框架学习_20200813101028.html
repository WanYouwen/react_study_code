<html>
<head>
  <title>React框架学习</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600475 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="398"/>
<h1>React框架学习</h1>

<div>
<span><div><br/></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(255, 0, 0); font-weight: bold;">React框架学习</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">网址： </span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">    中文网址：<a href="https://react.css88.com/" style="font-size: 16pt; font-weight: bold; color: rgb(235, 0, 115);">https://react.css88.com/</a></span></font></div><div><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">    英文网址：</span><a href="https://reactjs.org/" style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">https://reactjs.org/</a></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React的起源和发展</span></font></div><div><span style="font-size: 16pt;">    起初facebook在建设 instagram（图片分享）的时候，因为牵扯到一个东东叫数据流，那为了处理数据流并且还要考虑好性能方面的问题嘞，Facebook开始对市场上的各种前端MVC框架去进行一个研究，然而并没有看上眼的，于是Facebook觉得，还是自己开发一个才是最棒的，那么他们决定抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式，他们就自己开发了一套，果然大牛创造力还是很强大的。</span></div><div><br/></div><div><span style="font-size: 21.3333px;">前端的最好的ui框架  优雅</span></div><div><span style="font-size: 21.3333px;"><br/></span></div><div><font style="font-size: 16pt;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><b>React当前的版本有一个特点：函数式编程</b></span> </font></div><div>js的特点也是函数式编程</div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React的出发点</span></font></div><div><br/></div><div><span style="font-size: 16pt;">    基于HTML的前端界面开发正变得越来越复杂，其本质问题基本都可以归结于如何</span><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">将来自于服务器端或者用户输入的动态数据高效的反映到复杂的用户界面</span><span style="font-size: 16pt;">上。而来自Facebook的React框架正是完全面向此问题的一个解决方案，按官网描述，其出发点为：用于开发数据不断变化的大型应用程序（Building large applications with data that changes over time）。相比传统型的前端开发，React开辟了一个相当另类的途径，实现了前端界面的高性能高效率开发。</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React与传统MVC的关系</span></font></div><div><br/></div><div><span style="font-size: 16pt;">    轻量级的</span><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">视图层框架</span><span style="font-size: 16pt;">！</span></div><div><br/></div><div><span style="font-size: 16pt;">    React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React高性能的体现：虚拟DOM</span></font></div><div><span style="font-size: 21.3333px;"><span style="font-size: 21.3333px; font-weight: bold;">React是第一个将虚拟DOM应用在前端的框架</span></span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">React高性能的原理 SSSSSSSSSSSS：</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在Web开发中我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A-B,B-A，React会认为A变成B，然后又从B变成A  UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，部而对实际DOM进行操作的仅仅是Diff算法，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。数据驱动，声明式</span></div><div style="margin-left: 40px;"><span style="font-size: 21.3333px;">data  </span></div><div style="margin-left: 40px;"><span style="font-size: 21.3333px;">state(可以改变的state)</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React的特点和优势（面试）SSS</span></font></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#E30000" style="font-size: 16pt;"><b>1. 虚拟DOM</b></font></div><div><br/></div><div><font style="font-size: 16pt;">    我们以前操作dom的方式是通过document.getElementById()的方式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进行操作</font></div><div><br/></div><div><font style="font-size: 16pt;">    而reactjs定义了一套变量形式的dom模型，一切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的高，和主流MVC框架有本质的区别，并不和dom打交道</font></div><div><br/></div><div><font color="#E30000" style="font-size: 16pt;"><b>2. 组件系统（单向数据流） react中一切都是组件 </b></font></div><div><br/></div><div><font style="font-size: 16pt;">    react最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件 component</font></div><div><br/></div><div><font style="font-size: 16pt;">   <b> </b><b>那么什么是组件呢？</b></font></div><div><br/></div><div><font style="font-size: 16pt;">        组件指的就是同时包含了html、css、js、image元素的聚合体</font></div><div><br/></div><div><font style="font-size: 16pt;">使用react开发的核心就是将页面拆分成若干个组件，并且react一个组件中同时耦合了css、js、image，这种模式整个颠覆了过去的传统的方式</font></div><div><br/></div><div><font color="#E30000" style="font-size: 16pt;"><b>3. 单向数据流</b></font></div><div><br/></div><div><font style="font-size: 16pt;">    其实reactjs的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了</font></div><div><br/></div><div><font color="#E30000" style="font-size: 16pt;"><b>4. JSX  语法</b></font></div><div><font color="#E30000" style="font-size: 16pt;"><b>        cli3   render( h=&gt; h() )</b></font></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;">    在vue中，我们使用render函数来构建组件的dom结构性能较高，因为省去了查找和编译模板的过程，但是在render中利用createElement创建结构的时候代码可读性较低，较为复杂，此时可以利用jsx语法来在render中创建dom，解决这个问题，但是前提是需要使用工具来编译jsx</font></div><div><br/></div><div><font style="font-size: 16pt;">    createElement  繁琐   ----》  jsx(javascript+xml)  syntial sugar</font></div><div><br/></div><div><font style="font-size: 16pt;">    var div = document.createElement('DIV')</font></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">        var p= document.createElement('P')</span></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">        div.appendChild(p)</span></div><div><font style="font-size: 16pt;">    (</font></div><div><font style="font-size: 16pt;">        &lt;div&gt;</font></div><div><font style="font-size: 16pt;">            &lt;p&gt;&lt;/p&gt;</font></div><div><font style="font-size: 16pt;">        &lt;/div&gt;</font></div><div><font style="font-size: 16pt;">    )</font></div></div><div style="margin-left: 40px;"><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### 创建第一个组件</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生成版本</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">在这里一开始，我们先学习es5的组件写法，React.createClass，需要引入的是15+</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">react.js中有React对象，帮助我们创建组件等功能</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">react-dom.js中有ReactDOM对象，渲染组件的虚拟dom为真实dom的爆发功能</span></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">    </span></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">在编写react代码的时候会大量的使用到jsx代码，但是需要编译：</span></div><div><br/></div><div><span style="font-size: 16pt;">1. 浏览器端编译，通过引入browser、babel等对引入的script内的代码做编译</span></div><div><span style="font-size: 16pt;">2. 利用webpack等开发环境进行编译，将编译好的文件引入到应用中</span></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div><span style="font-size: 16pt;">    //创建组件</span></div><div><span style="font-size: 16pt;">    var Hello = React.createClass({</span></div><div><span style="font-size: 16pt;">        render:function () {</span></div><div><span style="font-size: 16pt;">            //render函数和Vue组件里的render完全一样，在vue组件中可以不用编写render函数，这个时候可以使用template模板来编写组件的虚拟dom结构，然后vue组件会自动讲模板compile成虚拟dom结构放入到render中执行，但是react需要编写render函数</span></div><div><br style="font-size: 16pt;"/></div><div><span style="font-size: 16pt;">            return (</span></div><div><span style="font-size: 16pt;">                //jsx语法 虚拟DOM</span></div><div><span style="font-size: 16pt;">                &lt;div&gt;asdasd&lt;/div&gt;</span></div><div><span style="font-size: 16pt;">            )</span></div><div><span style="font-size: 16pt;">            </span></div><div><span style="font-size: 16pt;">        }</span></div><div><span style="font-size: 16pt;">    })</span></div><div><span style="font-size: 16pt;">    //利用ReactDOM对象的render方法将组件渲染到某个节点里</span></div><div><span style="font-size: 16pt;">    ReactDOM.render(&lt;Hello/&gt;,document.getElementById(&quot;app&quot;)/app)</span></div><div><br/></div></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">组件是通过React.createClass创建的（ES5），在es6中直接通过class关键字来创建</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">组件其实就是一个构造器,每次使用组件都相当于在实例化组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">react的组件必须使用render函数来创建组件的虚拟dom结构</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">组件需要使用ReactDOM.render方法将其挂载在某一个节点上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">组件的首字母必须大写</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### JSX语法糖</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">JSX是一种语法，全称：javascript xml</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">JSX语法不是必须使用的，但是因为使用了JSX语法之后会降低我们的开发难度，故而这样的语法又被成为语法糖</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">在不使用JSX的时候，需要使用React.createElement来创建组件的dom结构，但是这样的写法虽然不需要编译，但是维护和开发的难度很高，且可读性很差</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">var world = React.createElement('h1',{className:'abc',id:'haha'},[</span></div><div><span style="font-size: 16pt;">    React.createElement('span',null,'Hello'),</span></div><div><span style="font-size: 16pt;">    React.createElement('mark',null,'React')</span></div><div><span style="font-size: 16pt;">])</span></div><div><span style="font-size: 16pt;">            </span></div><div><span style="font-size: 16pt;">//利用ReactDOM对象的render方法将组件渲染到某个节点里</span></div><div><span style="font-size: 16pt;">ReactDOM.render(world,document.getElementById(&quot;app1&quot;))</span></div><div><span style="font-size: 16pt;">```</span></div></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">及时使用了JSX语法了之后，也是需要将其编译成原生的createElement的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">JSX就是在js中使用的xml，但是，这里的xml不是真正的xml，只能借鉴了一些xml的语法，例如：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">最外层必须有根节点、标签必须闭合</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">jsx借鉴xml的语法而不是html的语法原因：xml要比html严谨，编译更方便</span></div><div style="margin-left: 40px;"></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### 组件dom添加样式   标签选择器  id 属性   style ={ { background: 'red'} }  class(className)</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在react里表达式的符号是 &quot;{  }&quot;,作用和vue的表达式作用是一样的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;p style = { {color:'red',fontSize:2+'em'} }&gt;Hello world&lt;/p&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如React.createClass的配置项中、render函数里、组件原型上、外链js文件中</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React推荐我们使用行内样式，因为react觉得每一个组件都是一个独立的整体</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">其实我们大多数情况下还是大量的在为元素添加类名、id以使用某些样式，但是需要注意的是，class需要写成className（因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;p className=&quot;bg-p&quot; id=&quot;myp&quot; style = { this.style }&gt;Hello world&lt;/p&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React Event</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在react中，我们想要给组件的dom添加事件的话，也是 需要在行内添加的方式，事件名字需要写成小驼峰的方式，值利用表达式传入一个函数即可</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">注意，在没有渲染的时候，页面中没有真实dom，所以是获取不到dom的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">给虚拟dom结构中的节点添加样式。在行内添加,写成驼峰形式，值是一个函数名，需要用{}包裹</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 16pt;">```</font></div><div><font style="font-size: 16pt;">handleClick:function (e) {</font></div><div><font style="font-size: 16pt;">    alert(1)</font></div><div><font style="font-size: 16pt;">},</font></div><div><font style="font-size: 16pt;">render:function () {</font></div><div><font style="font-size: 16pt;">    return (</font></div><div><font style="font-size: 16pt;">        &lt;div&gt;</font></div><div><font style="font-size: 16pt;">            &lt;button onClick = {this.handleClick} className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</font></div><div><font style="font-size: 16pt;">            &lt;button onDoubleClick = {this.handleClick} className=&quot;click-btn&quot;&gt;click&lt;/button&gt;</font></div><div><font style="font-size: 16pt;">        &lt;/div&gt;</font></div><div><font style="font-size: 16pt;">    )</font></div><div><font style="font-size: 16pt;">}</font></div><div>```</div></div><div style="margin-left: 40px;"><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### 组件嵌套</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">将一个组件渲染到某一个节点里的时候，会将这个节点里原有内容覆盖</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">组件嵌套的方式就是将子组件写入到父组件的模板中去，且react没有Vue中的内容分发机制（slot），所以我们在一个组件的模板中只能看到父子关系</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">var Hello = React.createClass({</span></div><div><span style="font-size: 16pt;">    render(){</span></div><div><span style="font-size: 16pt;">        return (</span></div><div><span style="font-size: 16pt;">            &lt;h1&gt;</span></div><div><span style="font-size: 16pt;">                Hello</span></div><div><span style="font-size: 16pt;">                &lt;World&gt;&lt;/World&gt;</span></div><div><span style="font-size: 16pt;">            &lt;/h1&gt;</span></div><div><span style="font-size: 16pt;">        )</span></div><div><span style="font-size: 16pt;">    }</span></div><div><span style="font-size: 16pt;">})</span></div><div><span style="font-size: 16pt;">var World = React.createClass({</span></div><div><span style="font-size: 16pt;">    render(){</span></div><div><span style="font-size: 16pt;">        return (</span></div><div><span style="font-size: 16pt;">            &lt;mark&gt;</span></div><div><span style="font-size: 16pt;">                World-&lt;Person/&gt;</span></div><div><span style="font-size: 16pt;">            &lt;/mark&gt;</span></div><div><span style="font-size: 16pt;">        )</span></div><div><span style="font-size: 16pt;">    }</span></div><div><span style="font-size: 16pt;">})</span></div><div><span style="font-size: 16pt;">//无状态组件</span></div><div><span style="font-size: 16pt;">var Person =function(){</span></div><div><span style="font-size: 16pt;">    return (&lt;mark&gt;lilei&lt;/mark&gt;)</span></div><div><span style="font-size: 16pt;">}</span></div><div><span style="font-size: 16pt;">ReactDOM.render(&lt;Hello/&gt;,app)</span></div><div><span style="font-size: 16pt;">```</span></div></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">&gt;注意，react中jsx里的注释要写成{/*  */}的方式</span></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React中的数据承载-Props/State</span></font></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">数据驱动、声明式渲染：</span></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">任意的视图变化都应该由数据来控制</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//$(&quot;.a&quot;).html(0)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">var num = 0</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">function renderNum () { $(&quot;.a&quot;).html(num) }</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">React也是基于数据驱动(声明式)的框架，组件中必然需要承载一些数据，在react中起到这个作用的是属性和状态（props &amp; state）</span></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 属性（props）  在组件外部传入（写在对应的组件上），或者内部设置（es5 getDefaultProps），组件内部通过this.props获得</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 状态（state）  在组件内部设置或者更改，组件内部通过this.state获得</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    设置： getInitialState(){ return {} }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    更改 ：自己状态自己更改  this.setState({key: value})</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 属性(props)</span></font></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">属性一般是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改</span></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">属性是描述性质、特点的，组件自己不能随意更改</span></div><div><br/></div><div><span style="font-size: 16pt;">使组件拥有属性的方式：</span></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">1. 在装载（mount）组件的时候给组件传入</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    传入数据的时候，除了字符串类型，其他的都应该包上表达式，但是为了规整，所有的数据传递，最好都包上{}</span></div><div><br/></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 18pt;">```</font></div><div><font style="font-size: 18pt;">var Gouzi = React.createClass({</font></div><div><font style="font-size: 18pt;">    render(){</font></div><div><font style="font-size: 18pt;">        console.log(this)</font></div><div><font style="font-size: 18pt;">        return (</font></div><div><font style="font-size: 18pt;">            &lt;div&gt;</font></div><div><font style="font-size: 18pt;">                &lt;p&gt;我的名字：{this.props.name}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">                &lt;p&gt;我的性别：{this.props.sex}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">                &lt;p&gt;我的年龄：{this.props.age}&lt;/p&gt;  </font></div><div><font style="font-size: 18pt;">                &lt;p&gt;我的父亲是：{this.props.father}&lt;/p&gt;                                              </font></div><div><font style="font-size: 18pt;">            &lt;/div&gt;</font></div><div><font style="font-size: 18pt;">        )</font></div><div><font style="font-size: 18pt;">    }</font></div><div><font style="font-size: 18pt;">})</font></div><div><br/></div><div><font style="font-size: 18pt;">let info = {</font></div><div><font style="font-size: 18pt;">    sex:'male',</font></div><div><font style="font-size: 18pt;">    father:'狗爸'</font></div><div><font style="font-size: 18pt;">}</font></div><div><br/></div><div><font style="font-size: 18pt;">ReactDOM.render(&lt;Gouzi {...info} name={&quot;大狗子&quot;} age={26}/&gt;,app)</font></div><div><font style="font-size: 18pt;">``</font>`</div></div><div style="margin-left: 40px;"><br/></div><div><br/></div><div><span style="font-size: 16pt; color: rgb(227, 0, 0);">    2. 父组件给子组件传入</span></div><div><br/></div><div><span style="font-size: 16pt;">        父组件在嵌套子组件的时候为子组件传入，传入的方式和上面的方式一样</span></div><div><br/></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 16pt;">```</font></div><div><font style="font-size: 16pt;">//父组件的render函数</font></div><div><font style="font-size: 16pt;">render(){</font></div><div><font style="font-size: 16pt;">    return (</font></div><div><font style="font-size: 16pt;">        &lt;div&gt;</font></div><div><font style="font-size: 16pt;">            &lt;p&gt;父组件：&lt;/p&gt;</font></div><div><font style="font-size: 16pt;">            &lt;hr/&gt;</font></div><div><font style="font-size: 16pt;">            &lt;Son name={'大狗子'}/&gt;</font></div><div><font style="font-size: 16pt;">            &lt;Son name={'二狗子'}/&gt;</font></div><div><font style="font-size: 16pt;">        &lt;/div&gt;</font></div><div><font style="font-size: 16pt;">    )</font></div><div><font style="font-size: 16pt;">}</font></div><div><font style="font-size: 16pt;">```</font></div></div><div style="margin-left: 40px;"><br/></div><div><span style="font-size: 16pt;">  </span> <span style="font-size: 16pt; color: rgb(227, 0, 0);"> </span><span style="font-size: 16pt; color: rgb(227, 0, 0);">3. 子组件自己设置</span></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">子组件可以通过getDefaultProps来设置默认的属性</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">getDefaultProps的值是函数，这个函数会返回一个对象，我们在这里对象里为组件设置默认属性</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这种方式设置的属性优先级低，会被外部传入的属性值所覆盖</span></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 16pt;">```</font></div><div><font style="font-size: 16pt;">getDefaultProps:function () {</font></div><div><font style="font-size: 16pt;">    console.log('getDefaultProps')</font></div><div><font style="font-size: 16pt;">    return {</font></div><div><font style="font-size: 16pt;">        name:'狗爸',</font></div><div><font style="font-size: 16pt;">        sonname:'二狗子'</font></div><div><font style="font-size: 16pt;">    }</font></div><div><font style="font-size: 16pt;">},</font></div><div><font style="font-size: 16pt;">//render</font></div><div><font style="font-size: 16pt;">&lt;p&gt;我是{this.props.sonname}的父亲-{this.props.name}&lt;/p&gt;</font></div><div><font style="font-size: 16pt;">```</font></div></div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">根据属性或状态，我们可以在render中的表达式里做一些逻辑判断，可以使用||、三元表达式、子执行函数等等</span></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div><font style="font-size: 18pt;">```</font></div><div><font style="font-size: 18pt;">getName(){</font></div><div><font style="font-size: 18pt;">    return this.props.name || '野狗子'</font></div><div><font style="font-size: 18pt;">},</font></div><div><font style="font-size: 18pt;">render:function () {</font></div><div><font style="font-size: 18pt;">    let {name} = this.props</font></div><div><font style="font-size: 18pt;">    return (</font></div><div><font style="font-size: 18pt;">    &lt;div&gt;</font></div><div><font style="font-size: 18pt;">        &lt;p&gt;我是子组件-{this.props.name || '野狗子'}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">        &lt;p&gt;我是子组件-{this.props.name?this.props.name:'野狗子'}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">        &lt;p&gt;我是子组件-{this.getName()}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">        &lt;p&gt;我是子组件-{(function (obj) {</font></div><div><font style="font-size: 18pt;">            return obj.props.name || '野狗子'</font></div><div><font style="font-size: 18pt;">        })(this)}&lt;/p&gt;</font></div><div><font style="font-size: 18pt;">    &lt;/div&gt;</font></div><div><font style="font-size: 18pt;">    )</font></div><div><font style="font-size: 18pt;">}</font></div><div><font style="font-size: 18pt;">```</font></div></div><div style="margin-left: 40px;"><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 状态(state)</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在组件中只能通过</span><span style="font-size: 16pt; font-weight: bold;">getInitialState</span><span style="font-size: 16pt;">的钩子函数来给组件挂载初始状态,在组件内部通过</span><span style="font-size: 16pt; font-weight: bold;">this.state</span><span style="font-size: 16pt;">获取</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.props和this.state是纯js对象,在vue中，$data属性是利用Object.defineProperty处理过的，更改$data的数据的时候会触发数据的getter和setter，但是react中没有做这样的处理，如果直接更改的话，react是无法得知的，所以，需要使用特殊的更改状态的方法：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">setState(params)</span></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在setState中传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须返回像上面方式一样的一个对象，函数可以接收prevState和props</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//1.</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">let doing = this.state.doing=='学习'+props.knowledge?'玩游戏':'学习'+props.knowledge</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.setState({doing})</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//2.</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.setState((prevState,props)=&gt;{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    return {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        doing:prevState.doing=='学习'+props.knowledge?'玩游戏':'学习'+props.knowledge</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">})</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 实现下拉菜单的方式</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 通过数据来控制元素的行内样式中display的值，或者去控制类名</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;ul style={{display:isMenuShow?'block':'none'}}&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">...</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;ul className={isMenuShow?'show':'hide'}&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 根据数据控制是否渲染改节点、组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    isMenuShow?&lt;ul&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;:''</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. 通过ref对dom、组件进行标记，在组件内部通过this.refs获取到之后，进行操作</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;ul ref='content'&gt;&lt;li&gt;国内新闻&lt;/li&gt;&lt;/ul&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">...</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.refs.content.style.display = this.state.isMenuShow?'block':'none'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 属性和状态的对比</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">相似点：</span><span style="font-size: 16pt;">都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">不同点：</span></font></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">1. 属性能从父组件获取，状态不能</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">2. 属性可以由父组件修改，状态不能</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">3. 属性能在内部设置默认值 ，状态也可以</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">4. 属性不在组件内部修改   ，状态要改</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">5. 属性能设置子组件初始值  ，状态不可以</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">6. 属性可以修改子组件的值，状态不可以</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">状态只和自己相关，由自己维护</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">属性不要自己修改，可以从父组件获取，也可以给子组件设置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;background-color: rgb(255, 250, 165);-evernote-highlight:true;">组件在运行时自己需要修改的数据其实就是状态而已</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    数据</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        1. props （可以由父组件传递过来，自己设置（getDefaultProps））                        <span style="font-size: 16pt; font-weight: bold;">属性和状态的对比</span></span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        2. state（独立个性 ，只和自己有关，由自己来维护）</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### 组件的生命周期</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react中组件也有生命周期，也就是说也有很多钩子函数供我们使用，下面是生命周期的图示：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><img src="React框架学习_files/life.jpg" type="image/jpeg" data-filename="life.jpg"/></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">组件是一个构造器，每一次使用组件都相当于在实例化组件，在这个时候，组件就会经历一次生命周期，从实例化实例开始到这个实例销毁的时候，都是一次完整的生命周期</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">组件的生命周期，我们会分为三个阶段，初始化、运行中、销毁</span></div><div style="margin-left: 40px;"></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 初始化阶段</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 实例化组件之后，组件的getDefaultProps钩子函数会执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    这个钩子函数的目的是为组件的实例挂载默认的属性</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 执行getInitialState为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态呢</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. 执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    多做一些初始数据的获取</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4. 执行render，渲染dom</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5. 执行componentDidMount ，相当于Vue里的mounted,多用于操作真实dom</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 运行中阶段</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. componentWillReceiveProps</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 21.3333px;">由状态来控制属性的更改</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 接下来就会执行shouldComponentUpdate,这个函数的作用：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    当属性或状态发送改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    相当于Vue中的beforeUpdate</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4. render，重新渲染dom</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5. componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 销毁阶段</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">相当于Vue里的beforeDestroy，所以说一般会做一些擦屁股的事情</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">为什么Vue中有destroyed，而react却没有componentDidUnmount</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">Vue在调用$destroy方法的时候就会执行beforeDestroy，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed处理，但是react执行完 </span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">怎么样就算组件被销毁：</span></font></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">1. 当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">2. 调用ReactDOM.unmountComponentAtNode(node) 方法来将某节点中的组件销毁</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### React中的事件对象</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react中对于事件进行了处理，解决了一些兼容性问题，react事件对象上面挂载着nativeEvent，这个就是原生的事件对象</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react对事件对象做了优化，如果不取值的话，值都是null</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### React中组件通信方式</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">父组件与子组件通信( props    ref( ref    ref =&gt;{el =&gt; this.el = el } ) )</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">1. 父组件将自己的状态传递给子组件，子组件当做属性来接收，当父组件更改自己状态的时候，子组件接收到的属性就会发生改变</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">2. 父组件利用ref对子组件做标记，通过调用子组件的方法以更改子组件的状态,也可以调用子组件的方法..</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">子组件与父组件通信</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">1. 父组件将自己的某个方法传递给子组件，在方法里可以做任意操作，比如可以更改状态，子组件通过this.props接收到父组件的方法后调用。</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">兄弟组件通信(  父亲当做中间人，  ref  )</span></span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">在react没有类似vue中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">复杂的非父子组件通信在react中很难处理，多组件间的数据共享也不好处理，所以我们会使用flux、redux来实现这样的功能，解决这个问</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"> flux</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">redux</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">bus</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### React中表单元素默认值</span></font></div><div><br/></div><div><span style="font-size: 16pt;">        在react中，如果需要 给表单元素设置默认value或者checked，需要设置成defaultValue/defaultChecked，否则设置默认值以后，用户无法更改</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### React中的mixins</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在vue中我们可以将一些通用的、公用的方法放入到某一个纯js对象中，然后，在需要使用改方法的组件中使用mixins配置（值为对象）将该js对象中的方法注入到组件中，这样就能实现代码复用，便于维护</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在React中曾经也有这样的api，但是在高版本react中推荐我们使用es6中的class来创建组件了，这个时候无法使用mixinsapi，所以mixins被废弃了，如果要使用公用代码抽离，我们可以使用模块化</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### React-keys</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    vue   v-for = ' item in items'  :key = 'item.id'</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">我们在react中循环列表数据的时候，需要对循环出来的虚拟jsx节点传入上key这个数据，</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 状态提升</span></font></div><div><br/></div><div><span style="font-size: 16pt;">      就是如果有多个组件共享一个数据，把这个数据放到共同的父级组件中来管理</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 组合</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    vue</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">        &lt;Item&gt;</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">            &lt;header slot ='header'&gt;&lt;/header&gt;</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">            &lt;h3&gt;&lt;/h3&gt;</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    &lt;/Item&gt;</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    </span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    &lt;template&gt;</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">        &lt;slot&gt;&lt;/slot&gt;</span></font></div><div><span style="font-size: 16pt; font-weight: bold;">    </span><span style="font-size: 16pt; font-weight: bold;">    &lt;slot name = 'header'&gt;&lt;/slot&gt;</span></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">    &lt;/template&gt;</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在vue中有一个内容分发叫slot，在react中也有实现，就是可以在使用组件的时候，在组件标签内部放入一些不固定的内容，在该组件的模板中，只有{this.props.children}来表示</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;"><span style="font-size: 16pt;">```</span></span></div><div><span style="font-size: 16pt;">//App</span></div><div><span style="font-size: 16pt;">&lt;Dialog</span></div><div><span style="font-size: 16pt;">    close={this.ToggleDialogShow} isShow={isDialogShow}</span></div><div><span style="font-size: 16pt;">&gt;</span></div><div><span style="font-size: 16pt;">    &lt;ContentA/&gt;</span></div><div><span style="font-size: 16pt;">    &lt;ContentA/&gt;</span></div><div><span style="font-size: 16pt;">    &lt;ContentB/&gt;</span></div><div><span style="font-size: 16pt;">&lt;/Dialog&gt;</span></div><div><br style="font-size: 16pt;"/></div><div><span style="font-size: 16pt;">//dialog</span></div><div><span style="font-size: 16pt;">&lt;div style={{display:isShow?'block':'none'}} className=&quot;dialog&quot;&gt;</span></div><div><span style="font-size: 16pt;">    &lt;Button handler={this.props.close} text=&quot;关闭&quot;/&gt;   </span></div><div><span style="font-size: 16pt;">    {this.props.children}//这里就是slot</span></div><div><span style="font-size: 16pt;">&lt;/div<span style="font-size: 16pt;">&gt;</span></span></div><div><span style="font-size: 16pt;">```</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### webpack</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">前端工程化： npm、cnpm、yarn、bower | grunt 、 gulp 、webpack</span></div><div><br/></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">gulp： 基于流的前端自动化构建工具，基于流的任务式的工具</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">webpack： 是一款一些选项</span><span style="font-size: 16pt;">模块化打包工具，webpack是基于配置的，通过配置</span><span style="font-size: 16pt;">来让webpack执行打包任务。</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">npm i webpack -g</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">npm i webpack-cli -g (4.0+)</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">npm i yarn -g</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 21.3333px;">关注微信的公众号： 前端大全 </span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 21.3333px;">微博去关注vue的作者： 尤小右</span></div><div style="margin-left: 80px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">npm不行就cnpm，cnpm不行就yarn，失败了多装几次</span></div><div><br/></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">webpack在打包的时候，依靠依赖关系图，在打包的时候需要告知webpack两个概念：入口和出口</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">一般情况下，我们需要使用webpack.config.js（webpack的配置文件）进行配置</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### entry</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">entry配置项目打包的入口，值可以为单个的字符串执行某一个文件的地址，这个时候该文件就是入口文件，webpack会根据入口文件里各模块间的关系形成依赖关系图，然后根据依赖关系图进行打包</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">entry:'./src/app.js',</span></div><div><span style="font-size: 16pt;">output:{</span></div><div><span style="font-size: 16pt;">    path:path.join(__dirname,'build'),</span></div><div><span style="font-size: 16pt;">    filename:'app.js'</span></div><div><span style="font-size: 16pt;">}</span></div></div><div><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">但是有的时候我们需要的是多入口，我们就写成数组的形式，数组里的每一个字符串地址指向的都是一个独立的入口，webpack会将这些入口的依赖打包</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">entry:['./src/app.js','./src/vendor.js'],</span></div><div><span style="font-size: 16pt;">output:{</span></div><div><span style="font-size: 16pt;">    path:path.join(__dirname,'build'),</span></div><div><span style="font-size: 16pt;">    filename:''确定名字的时候，这里会打包成main.js</span></div><div><span style="font-size: 16pt;">}</span></div><div><span style="font-size: 16pt;">```</span></div></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">刚才的两种entry配置都只会打包出一个js文件，但是在某一个应用中我们可能需要将js根据依赖关系打包成多个js文件，并且在多页面应用中，我们也确实不可能只使用一个js文件，那么我们就可以使用如下的配置：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">    entry:{</span></div><div><span style="font-size: 16pt;">        app:'./src/app.js',</span></div><div><span style="font-size: 16pt;">        vendor:'./src/vendor.js'</span></div><div><span style="font-size: 16pt;">    },</span></div><div><span style="font-size: 16pt;">    output:{</span></div><div><span style="font-size: 16pt;">        path:path.join(__dirname,'build'),</span></div><div><span style="font-size: 16pt;">        filename:'[name]_[hash].js'</span></div><div><span style="font-size: 16pt;">    }</span></div><div><span style="font-size: 16pt;">```</span></div></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这样，因为filename里写成名字是[name],所以会根据entry的配置的键名来为打包出的js文件命名，hash是每次打包的一个随机的hash值，可以用来做版本控制</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### output</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在这里我们配置打包输出的一些选项</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">filename可以确定打包出来的文件的名字，在里面我们可以使用[name],[hash]这样的占位符</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">path配置打包出去的文件的路径，需要是绝对路径</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### env</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在命令行或者终端中执行 webpack --env hello命令，就相当于在打包的时候传入一个参数为hello</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在webpack.config.js中可以暴露出一个函数，这个函数就可以接收到env参数，当然函数就可以根据env参数来有选择的返回某一个或多个配置对象</span></div><div style="margin-left: 40px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 18pt;">```</font></div><div><font style="font-size: 18pt;">module.exports = (env)=&gt;{</font></div><div><font style="font-size: 18pt;">    if(env=='production'){</font></div><div><font style="font-size: 18pt;">        return productionConfig</font></div><div><font style="font-size: 18pt;">    }</font></div><div><font style="font-size: 18pt;">    return developmentConfig</font></div><div><font style="font-size: 18pt;">}</font></div><div><span style="font-size: 16pt;">```</span></div></div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">--watch 可以让webpack去监听文件的改变。</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">可以在package.json里的scripts中配置一些快捷操作，通过npm run来运行</span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### plugins</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在webpack编译用的是loader，但是有一些loader无法完成的任务，交由插件（plugin）来完成，插件的时候需要在配置项中配置plugins选项，值是数组，可以放入多个插件的使用，而一般的插件都是一个构造器，我们只需在plugins数组中放入该插件的实例即可，在实例化插件的时候又可以传入options，对插件的使用进行配置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">html-webpack-plugin</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这个插件可以选择是否依据模板来生成一个打包好的html文件，在里面可以配置、title、template、filename、minify等选项，详情请查阅[文档](</span><a href="https://segmentfault.com/a/1190000007294861" style="font-size: 16pt;">https://segmentfault.com/a/1190000007294861</a><span style="font-size: 16pt;">)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在这个插件里，我们可以使用jade、hbs、ejs等模板引擎来编译成html，这里举例jade的配置：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">[文档](</span><a href="https://segmentfault.com/a/1190000000357534" style="font-size: 16pt;">https://segmentfault.com/a/1190000000357534</a><span style="font-size: 16pt;">)</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">```</span></div><div><span style="font-size: 16pt;">npm</span><span style="font-size: 16pt;">'jade-loader'</span></div><div><span style="font-size: 16pt;">        }</span></div><div><span style="font-size: 16pt;">    ]</span></div><div><span style="font-size: 16pt;">},</span></div><div><span style="font-size: 16pt;">plugins:[</span></div><div><span style="font-size: 16pt;">    new HtmlWebp <span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">i jade jade-loader --save-dev</span></span></div><div><br style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);"/></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">module:{</span></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">    rules:[</span></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">        {</span></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">            test:/\.jade$/,</span></div><div><span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">            use:</span><span style="font-size: 16pt;">ackPlugin({</span></div><div><span style="font-size: 16pt;">        // title:'webpack-config-demo',</span></div><div><span style="font-size: 16pt;">        template:'./src/index.jade',</span></div><div><span style="font-size: 16pt;">        filename:'index.html'</span></div><div><span style="font-size: 16pt;">    })</span></div><div><span style="font-size: 16pt;">]</span></div><div><span style="font-size: 16pt;">```</span></div></div><div><br/></div><div><span style="font-size: 21.3333px;background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 21.3333px; font-weight: bold;-evernote-highlight:true;">extract-text-webpack-plugin 分离css</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold;background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">cnpm i extract-text-webpack-plugin@next -D</span></div></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### webpack-dev-server</span></font></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">webpack相辅相成的有一个server功能工具可以提供开发的热更新服务器</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">npm install webpack-dev-server -g</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">npm install webpack-dev-server -D</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">第一种启动方式： 直接执行webpack-dev-server,如果有需要配置的选项，在后面跟上参数即可。例如</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">webpack-dev-server --hot true</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">第二种启动方式：在webpack.config.js中配置devServer的选项，执行webpack-dev-server就ok</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">devServer:{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    port:9000,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    contentBase:'./build',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    historyApiFallback: true,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    open: true,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    proxy:{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">```</span></font></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### LOADERS</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在webpack中专门有一些东西用来编译文件、处理文件，这些东西就叫loader，loader的使用就是在配置项中，设置module，在module中设置rules值为数组，在数组里放入多个匹配规则：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">module:{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    rules:[</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        {test:/\.css$/,use:'css-loader'}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ],</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    //before</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    loaders:[</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        {test:/\.css$/,loader:'css-loader'}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ],</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">test为此次匹配要匹配的文件正则规则，use代表要使用的loader</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">使用url-loader可以将css中引入的图片（背景图）、js中生成的img图片处理一下，生成到打包目录里</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">视图html-withimg-loader可以将html中img标签引入的img图片打包到打包目录</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">file-loader</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.(png|jpe?g|svg|gif)$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    // use:'url-loader?limit=1000&amp;name=images/[hash:8].[name].[ext]'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    use:[</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            loader:'url-loader',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            options:{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                limit:1000,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                name:'/static/images/assets/[hash:8].[name].[ext]'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ]</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">},</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.html$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    use:'html-withimg-loader'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">处理css：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">cnpm i css-loader style-loader --save-dev</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">配置：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.css$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    use:['style-loader','css-loader']</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">注意。webpack中loader的使用是从后往前的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">css-loader可以将引入到js中的css代码给抽离出来，style-loader可以将抽离出来的css代码放入到style标签中</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">处理sass</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">test:/\.scss$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">use:['style-loader','css-loader','sass-loader']</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">},</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">将引入项目的css文件、scss文件抽成一个文件，引入到页面中</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">cnpm i extract-text-webpack-plugin</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">const ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">///loader</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.css$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    use:ExtractTextWebpackPlugin.extract({</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      fallback: &quot;style-loader&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      use: &quot;css-loader&quot;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    })</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">},</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.scss/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    use:ExtractTextWebpackPlugin.extract({</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      fallback: &quot;style-loader&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      use: [&quot;css-loader&quot;,&quot;sass-loader&quot;]</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    })</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">///plugin</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">new ExtractTextWebpackPlugin({</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    filename:'app.css',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    allChunks:true</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">})</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">因为ExtractTextWebpackPlugin对webpack4支持的不是很好，所以我们这样解决：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">cnpm i extract-text-webpack-plugin@next -D</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">yarn add extract-text-webpack-plugin@next -D</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">@next下载的就是最最新的版本，可能是开发版本</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">webpack-dev-server进行了一个优化，在跑起服务的时候，会将编译结果保存在内存里，不会实时的输出的打包结果</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">css兼容优化处理：post-css 、autoprefixer、</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">处理es6：</span></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">需要的依赖：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&quot;babel&quot;: &quot;^6.23.0&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&quot;babel-core&quot;: &quot;^6.24.1&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&quot;babel-loader&quot;: &quot;^7.0.0&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">rules：</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    test:/\.js$/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    exclude: /node_modules/,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    loader:'babel-loader',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    query: {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        presets: ['es2015','react']</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">     }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### ES6中的react</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">1.创建组件：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">使用class来创建组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">class App extends</span> <a href="http://react.component/" style="font-size: 16pt;">React.Component</a> <span style="font-size: 16pt;">{</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">2.默认状态的设置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在es6中不再使用getInitialState来设置默认状态，而是在constructor里面直接给this.state上挂载状态</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">class App extends Component {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    constructor(props){</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        super(props)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        this.state={</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            doing:'吃饭'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">3. 默认属性的设置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在es6中，通过给类设置defaultProps属性来设置默认属性</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">App.defaultProps = {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    name:'App根组件'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">4. 做属性传参验证</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import PropTypes from 'prop-types';</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">App.propTypes = {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    name:PropTypes.string</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="background-color: rgb(255, 250, 165);font-size: 16pt;-evernote-highlight:true;">5.钩子函数有变化</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">getDefaultProps、getInitialState没有了</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">多出了constructor,而这个函数本身是类的构造器，在这里相当于getDefaultProps、getInitialState的结合</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### create-react-app 脚手架</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">npm install create-react-app -g</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">create-react-app my-app //生成一个react开发模板在my-app目录</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//生成的过程特别缓慢，可以使用yarn工具来下载，也就是说先去下载安装yarn   ：npm install yarn -g</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当我们要进行二次配置的时候，需要找到node_modules文件夹里的react-scripts进行配置，但是当我们执行npm run eject就可以将配置文件抽出，方便开发配置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 16pt;">1. 全局安装 create-react-app  这个脚手架</font></div><div><font style="font-size: 16pt;">    npm/cnpm i create-react-app -g</font></div><div><font style="font-size: 16pt;">    yarn add create-react-app global</font></div><div><font style="font-size: 16pt;">2. 创建项目</font></div><div><font style="font-size: 16pt;">    create-react-app project</font></div><div><font style="font-size: 16pt;">3. cd project</font></div><div><font style="font-size: 16pt;">4. 进行配置文件抽离</font></div><div><font style="font-size: 16pt;">    yarn eject</font></div><div><font style="font-size: 16pt;">5. 启动项目</font></div><div><font style="font-size: 16pt;">    yarn start / npx react-scripts start</font></div></div><div><br/></div></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### 无状态组件</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">当我们使用某些组件的时候，发现，该组件不需要拥有自己的状态，只需要接收到外界传入的属性之后做出相应的反应即可</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这样的话，我们可以利用纯函数的方式将其制作成无状态组件，提高性能</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import React from 'react'</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">const Button = (props)=&gt;{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    return &lt;button onClick={props.handler}&gt;我要花钱&lt;/button&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">export default Button</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### Flux</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在2014年，facebook提出了Flux，Flux 是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">其实FLUX在react里的应用就类似于vue中的vuex的作用，但是</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在vue中，vue是完整的mvvm框架，而vuex只是一个全局的插件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react只是一个视图层的框架，在flux是一个架构思想，我们在做项目的时候使用flux架构的话要比单纯使用react要简单很多，这个时候，react在整个FLUX架构中担任某一个角色的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react在这里只是充当了FLUX架构体系中的view层</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">Flux的组成部分：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* View： 视图层</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* ActionCreator（动作创造者）：视图层发出的消息（比如mouseClick）</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* Dispatcher（派发器）：用来接收Actions、执行回调函数</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">Flux的流程：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 组件获取到store中保存的数据挂载在自己的状态上</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 用户产生了操作，调用actions的方法</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. actions接收到了用户的操作，进行一系列的逻辑代码、异步操作</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4. 然后actions会创建出对应的action，action带有标识性的属性</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5. actions调用dispatcher的dispatch方法将action传递给dispatcher</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">6. dispatcher接收到action并根据标识信息判断之后，调用store的更改数据的方法</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">7. store的方法被调用后，更改状态，并触发自己的某一个事件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">8. store更改状态后事件被触发，该事件的处理程序会通知view去获取最新的数据</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;"><img src="React框架学习_files/flux.png" type="image/png" data-filename="flux.png"/></span></div><div><br/></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">##### redux</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 代码结构</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 组件之间的通信</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">如果你不知道是否需要 Redux，那就是不需要它</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">只有遇到 React 实在解决不了的问题，你才需要 Redux</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">* 用户的使用方式非常简单</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">* 用户之间没有协作</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">* 不需要与服务器大量交互，也没有使用 WebSocket</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0);">* 视图层（View）只从单一来源获取数据</span></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">需要使用redux的项目:</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 用户的使用方式复杂</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 不同身份的用户有不同的使用方式（比如普通用户和管理员）</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 多个用户之间可以协作</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 与服务器大量交互，或者使用了WebSocket</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* View要从多个来源获取数据</span></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">从组件层面考虑，什么样子的需要redux：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 某个组件的状态，需要共享</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 某个状态需要在任何地方都可以拿到</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 一个组件需要改变全局状态</span></span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">* 一个组件需要改变另一个组件的状态</span></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">redux的设计思想：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">1. Web 应用是一个状态机，视图与状态是一一对应的。</span></div><div style="margin-left: 80px;"><span style="font-size: 16pt;">2. 所有的状态，保存在一个对象里面（唯一数据源）。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">redux的流程：</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;"><img src="React框架学习_files/redux.jpg" type="image/jpeg" data-filename="redux.jpg"/></span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1.store通过reducer创建了初始状态</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2.view通过store.getState()获取到了store中保存的state挂载在了自己的状态上</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3.用户产生了操作，调用了actions 的方法</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4.actions的方法被调用，创建了带有标示性信息的action</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5.actions将action通过调用store.dispatch方法发送到了reducer中</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">6.reducer接收到action并根据标识信息判断之后返回了新的state</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">7.store的state被reducer更改为新state的时候，store.subscribe方法里的回调函数会执行，此时就可以通知view去重新获取state</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&gt; 注意：flux、redux都不是必须和react搭配使用的，因为flux和redux是完整的架构，在学习react的时候，只是将react的组件作为redux中的视图层去使用了。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">reducer必须是一个纯函数：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">纯函数是函数式编程的概念，必须遵守以下一些约束。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">不得改写参数</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">不能调用系统 I/O 的API</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">// State 是一个对象</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">function reducer(state, action) {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  return Object.assign({}, state, { thingToChange });</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  // 或者</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  return { ...state, ...newState };</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">// State 是一个数组</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">function reducer(state, action) {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  return [...state, newItem];</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">我们可以通过在createStore中传入第二个参数来设置默认的state，但是这种形式只适合于只有一个reducer的时候</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">划分reducer</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">因为一个应用中只能有一个大的state，这样的话reducer中的代码将会特别特别的多，那么就可以使用combineReducers方法将已经分开的reducer合并到一起</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">注意：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 分离reducer的时候，每一个reducer维护的状态都应该不同</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 通过store.getState获取到的数据也是会安装reducers去划分的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. 划分多个reducer的时候，默认状态只能创建在reducer中，因为划分reducer的目的，就是为了让每一个reducer都去独立管理一部分状态</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">### React-router</span></font></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">       <a href="https://reacttraining.com/react-router/web/api/Route" style="font-size: 16pt; font-weight: bold;">https://reacttraining.com/react-router/web/api/Route</a></span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">市场上的react-router的版本有1、2、3、4,1-3的差别不大，使用于16.0.0以下的版本</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">react-router 4.0 适用于16.0.0以上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">在这里使用15.6.1的react。这个版本的react允许使用React.createClass来创建组件，在16以上只能使用class类的方式来创建</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 渲染根组件的时候，最外层包裹上Router组件，在其上可以设置history属性，值可以是hashHistory||browserHistory</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    当值为hashHistory的时候，url的变化为hash值的变化，router会去检测hash变化来实现组件的切换</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">   当值为browserHistory的时候，url的变化为path的变化，需要后端进行配置</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. Router中使用Route组件来描述每一级路由，Route上有path、component属性，代表着当path改变成...的时候，就渲染..组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. 在需要切换路由组件的地方，通过this.props.children来表示对应路由组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4. 在Route中可以多次嵌套Route来实现多级路由</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5. IndexRoute可以设置该路由中的默认子路由</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;IndexRoute component={Home}/&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">6. IndexRedirect可以设置在进入该路由之后马上跳转到哪里</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;IndexRedirect to='home'/&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">7. 使用Redirect组件可以做到从一个路由马上重定向到其他路由,利用这样的属性，当我们form设置为'*'的时候，就可以将匹配不到的路由重定向到某げ路由下</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;Redirect from=&quot;*&quot; to=&quot;home&quot;/&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">8. 可以在配置Route的时候给path里加入/:param 才表示此路由需要参数</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">传入的时候，querystring参数可以在Link里的query中传入和设置，在目标组件中，通过this.props中的，params、routePrams、location等来接收参数</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">9. 可以通过过Router传入routes参数，值为数组，来设置路由配置：</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">const routeConfig = [</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  { path: '/',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    component: App,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    indexRoute: { component: Home },</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    childRoutes: [</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      { path: 'home', component: Home },</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      { path: 'news',</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        component: News,</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        childRoutes: [</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">          { path: 'inside', component: Inside },</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">          { path: 'outside',component:Outside}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        ]</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      },</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      { path: 'detail/:id', component: Detail },</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">      {path:'*',component:Home}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ]</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">]</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">ReactDOM.render(</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    &lt;Router routes={routeConfig} history={hashHistory}&gt;&lt;/Router&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ,document.getElementById('app'))</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">10. 编程式导航</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 在路由组件中通过this.props.history获取到history对象，利用里面push、replace、go、goBack方法来进行隐式跳转</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 可以从react-router中引入browserHistory或者hashHistory调用里面的push、replace、go、goBack方法来进行隐式跳转</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">11. 可以通过在路由配置上设置 onLeave和onEnter路由钩子来监听路由的变化</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### UI组件库</span></font></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">关于React的UI组件库市场上也有很多，在这里我们使用蚂蚁金服开发的AntDesign组件库</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这是PC端的，移动端的是Antd-Mobile</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### React-redux</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">这个库或者说工具是redux的开发者专门为react创建出来的，为我们在react中使用redux提供便利</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">起到的是桥梁的作用，能将react和redux更好的连接在一起</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React-Redux 将所有组件分成两大类：UI 组件/木偶组件（presentational component）和容器组件/智能组件（container component）。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">UI 组件有以下几个特征。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 只负责 UI 的呈现，不带有任何业务逻辑</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 没有状态（即不使用this.state这个变量）</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 所有数据都由参数（this.props）提供</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 不使用任何 Redux 的 API</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">容器组件的特征恰恰相反。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 负责管理数据和业务逻辑，不负责 UI 的呈现</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 带有内部状态</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 使用 Redux 的 API</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">使用方法及步骤：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 使用Provider组件，包裹在应用的最外层，并为Provider注入store属性，此时，Provider就会将自己的store属性传递给子组件组合中的容器组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 使用connect函数，可以根据一个现有的UI组件生成一个容器组件，且我们在使用的时候，其实一直在使用的都是容器组件，connect函数执行之后返回一个函数，将返回的函数传入UI组件并执行之后就会生成一个容器组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. connect函数有两个参数：mapStateToProps,mapDispatchToProps</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* mapStateToProps的作用很简单，就是将redux中的state传递到UI组件的props上，此参数是一个函数，接收到store的state然后再返回一个对象，返回的对象中的属性就会传递到UI组件的属性上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    mapStateToProps对store进行了订阅，只要state更改，mapStateToProps会自动执行并获取到最新的state传入到UI组件的属性上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* mapDispatchToprops 函数，接收到dispatch参数，其实就是store.dispatch，返回的对象中设置的方法可以使用到dispatch，且能传入到UI组件的属性上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">那么，有了mapDistpatchToProps之后，我们就不需要actions了吗？</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">我们需要将一些复杂的业务逻辑，或者说异步的业务逻辑抽离出来放入到actions里面去，也就是后所mapDispatchToProps里自己创建的只是一些简单的方法就可以了</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">第一次使用react-redux等工具的做法</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">创建了actionCreator，专门生成action，又设置 了actions，在actions里放一些异步的、复杂的操作之后，调用actionCreator生成action再dispatch到reducer</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">其实我们上面创建actions的目的，就是因为ActionCreator不能做复杂的动作，其实我们可以使用redux-thunk来对reducer创建中间件，让actionCreator的方法能返回一个函数，这个函数就可以接收到dispatch，且做出异步操作之后dispatch出action，也就是说，我们不需要再创建actions来分离异步复杂操作，而且直接可以在ActionCreator里写异步方法</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">步骤：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. 对store中的reducer使用redux-thunk</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import {createStore,applyMiddleware} from 'redux'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import reducer from './reducer'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import thunk from 'redux-thunk'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">const store = createStore(reducer,applyMiddleware(thunk))</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">export default store</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 在ActionCreator的方法中返回方法来做异步处理</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">const actions_thunk = {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    clearCart(){</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        //做异步操作之后生成action且dispatch</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        return (dispatch)=&gt;{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            setTimeout(function(){                </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                localStorage.removeItem('cars')</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                let action = change_cars([])</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                dispatch(action)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            },500)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        </span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">}</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. 可以将actionCreator的方法利用bindActionCreator放入到mapDispatchToProps中</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import {bindActionCreators} from 'redux'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">import actions_thunk from '../../redux/ActionCreators/actions_thunk'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">export default connect(state=&gt;state,dispatch=&gt;{</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    return {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        actions_thunk:bindActionCreators(actions_thunk,dispatch)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">})(ClearCar)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">///</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">button onClick={this.props.actions_thunk.clearCart}</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">其实，现在有这样的流行做法：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">将所有的数据都交由redux管理，这样的话，我们的组件在UI层的逻辑就更纯粹了,而且可以做到数据缓存，比如，A组件获取了数据放入到redux中，当A组件被切换掉之后重新切换回来的时候，数据依然在redux中可以找到，也就是说直接取出来用就ok，不需要重新获取</span></div><div><br/></div><div><br/></div><div><span style="font-size: 18pt; color: rgb(235, 0, 115);">redux-thunk 中间件理解</span></div><div><br/></div><div><a href="https://blog.csdn.net/kuangshp128/article/details/67632683" style="font-size: 18pt; color: rgb(235, 0, 115);">https://blog.csdn.net/kuangshp128/article/details/67632683</a></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### React 扩展</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. ref推荐使用函数的方法：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 字符串方式</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;Son ref=&quot;son&quot;&gt;&lt;/Son&gt;</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.refs.son</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">* 函数方式(推荐)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;Son ref={(el)=&gt;{this.son = el}}&gt;&lt;/Son&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">//</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">this.son</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">```</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;transition name = &quot;abc&quot;&gt;</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">&lt;/transition&gt;</span></div><div><br/></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">#### 考试题：</span></font></div><div><br/></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">1. react的特点不包括什么？</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">  声明式设计、高效、灵活、（双向数据流）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">2. 动画可以使用哪个第三方插件实现：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    (ReactTransitionGroup)/animate.css/transitionTranslate/redux-thunk</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">3. ReactRouter中，路由的onLeave应该写在哪里:</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    路由对应的组件中、父组件中、(路由组件中)、最外层大组件中</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">4. react-redux中的connect方法的返回值是一个:</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ContainerComponent = connect()(UIComponent)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    对象、(容器组件)、UI组件、数组</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">5. react中常提到的中间件的概念，指的是：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    react中间件、flux中间件、(redux中间件)、react-redux中间件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">6. redux设计的三大原则：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    (store唯一/唯一数据源、</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    state只读、</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    reducer是纯函数)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    reducer只读</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">7. 哪些不是react-router的组件：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    (Provider)、Route、Router、(MapStateToProps)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">8. 下面哪些方法可以使componentWillUpdate执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    属性更改或者状态更改</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">9. 请简述对虚拟dom的理解，为什么使用虚拟DOM可以极大的提升react的性能</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">   虚拟dom是真实dom的js对象映射，使用虚拟dom，避免对原生dom的创建和比对，取而代之的创建和比对的是js对象</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">   原生dom的创建和比对是非常消耗性能的，而js对象的对比和创建对性能开销很小，从这种方式来提供应用的性能</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">10. 请说明在react中ref的作用，并写出使用ref的两种方式，说明哪一种是官方推荐的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    ref可以使我们在react对dom或者子组件做出标记并获取：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    &lt;Son ref=&quot;son&quot;&gt;&lt;/Son&gt;//this.refs.son</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    &lt;Son ref={(el)=&gt;{this.son = el}}&gt;&lt;/Son&gt;//this.son(官方推荐)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">11. 说明react中，父子组件项目传值的方式，并说明在大型项目中为什么要引入flux或者redux这种开发架构</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    父组件将自己的状态当成属性传递给子组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    父组件将自己的方法传递给子组件，子组件在调用的时候传参</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    父组件通过ref获取到子组件，调用子组件的方法传参</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    react是一款视图层的轻量级前端框架，大量的非父子组件通信、状态共享会导致整个项目数据复杂，难以维护，所以react不适合处理大量的数据通信，为了解决这个问题，引入了FLUX、REDUX这样的数据架构，react结合FLUX或者redux才能实现比较复杂的前端项目</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">12. 在react中，列表循环尽量不要使用index作为key值，这和diff算法有关系，请简述diff算法中key值有什么作用，为什么key中使用index值会降低代码性能</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    key值是diff算法中对比两个虚拟dom的最重要参考，决定了哪些列表中的组件可以复用，如果使用index作为key中，列表数据改变后，会导致同一个dom元素的key中发送改变，本来可以复用的组件必须重新创建，降低页面性能，除非列表不需要改变，一般情况不使用index作为key值</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">13. 请列举你所了解的react中的性能优化</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 没必要存在store中的数据，存在state中就可以</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 函数的this执行放在constructor中改变</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 和页面显示无关的数据不要放在state中</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * shouldComponentUpdate来判断组件是否需要重新render(使用pureComponent)</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 使用性能分析工具进行性能分析，找问题解决问题</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">13.1 pureComponnet</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    pureComponnet里如果接收到的新属性或者是更改后的状态和原属性、原状态相同想等的话，就不会去重新render了</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    在里面也可以使用shouldComponentUpdate，而且。是否重新渲染以shouldComponentUpdate的返回值为最终的决定因素</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    class ABC extends pureComponnet {</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">14. 请说明react中引入redux-thunk、redux-promise这两种中间件可以解决什么样的问题</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    通常情况下，action只是一个对象，不能包含异步操作，这导致了很多创建action的逻辑只能写在组件中，代码量较多也不便于复用，同时对该部分代码测试的时候也比较困难，组件的业务逻辑也不清晰，使用中间件了之后，可以通过actionCreator异步编写action，这样代码就会拆分到actionCreator中，可维护性大大提高，可以方便于测试、复用，同时actionCreator还集成了异步操作中不同的action派发机制，减少编码过程中的代码量</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">15. 画图说明redux的架构，写出redux中常用的函数</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    dispatch , subscribe,combineReducers,getState,createStore</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">16. 简述react-redux结合react-router在项目中的使用方式</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 创建store，编写reducer</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 在&lt;Router/&gt;外面嵌套&lt;Provider store={store}&gt;&lt;/Provider&gt;，将store传递给各个子组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 编写UI组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 使用react-redux的connect方法结合mapStateToProps、mapDispatchToProps生成容器组件，容器组件和store连接在一起</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    router4</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 创建store，编写reducer</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 在&lt;Router/&gt;外面嵌套&lt;Provider store={store}&gt;&lt;/Provider&gt;，将store传递给各个子组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 编写UI组件</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 使用react-redux的connect方法结合mapStateToProps、mapDispatchToProps生成容器组件，容器组件和store连接在一起</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    * 如果某一个组件不是路由组件，却需要使用router相关api，并且还需要使用store中的state的时候，需要在最外层包裹withRouter，里面再使用connect生成容器组件</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">17. 下列说法错误的是：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    （React是一款专注于数据层的前端框架）、react中需要调用setState方法来重置状态、react中的虚拟dom可以提升框架自身的性能、（react是一款符合MVVM设计思想的前端框架）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">18. 关于前端组件化说法错误的是：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    前端组件使得复杂的代码得以被更好的划分、组件化的代码设计方式增加了代码的可复用性、（在拆分组件的时候将组件拆分的越小越细越好）、组件化开发是一种设计思想，不是react独享的</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">19. 在react中，异步获取ajax数据一般放在那个生命周期函数：componentWillMount</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">20. 使用es6定义组件，可以在那个生命周期钩子函数里使用this.state=state 对state进行赋值。而不需要调用this.setState方法：constructor</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">21. 在redux中，重要的组成部分不包括：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    store、action、reducer、（dispatcher）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">22. webpack中html-webpack-plugin插件可以完成的任务是：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    (在打包输出目录中自动生成index.html)、(向打包目录中的index.html文件内插入打包生成的js文件引用)、将js源码中引用的css代码抽离ちゅ单独的css文件并放置到打包输出目录、(像打包输出目录中的index.html文件插入打包生成的css引用)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">23. 关于jsx，说明正确的是：(ad)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    a:jsx中可以通过{}来使用js的表达式，b:jsx中可以通过{}来使用js的代码，c:jsx中可以使用style={color:'red'}来设置元素的样式、d:jsx代码会被解析成一个js对象</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">24. react组件被挂载到页面 的时候，被执行的生命周期函数包括：(ab)</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    a: componentWillMount,b:render,c:componentDidUpdate,d:shouldComponentUpdateMMMMMC</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">25. 在自定义的react组件中，哪些生命周期函数可以不写（acd）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    a: constructor b:render c:componentWillMount d:componentWillUnmount</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">26. 说法正确的是：（ab）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    a: 父组件通过属性的方式给子组件传值，b:子组件通过props接收父组件的值，c:state中和页面无关的属性发送变化时，render不会执行，d:shouldComponentUpdate函数的两个参数分别是当前的state和当前的props</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">27. 在react组件中，当（props或者state）发送变化的时候，会导致render生命周期函数重新执行</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">28. 使用react-redux时，页面上的组件需要被拆分成（容器）组件和（UI）组件，通过使用（connect/mapStateToProps）方法，可以把store中固定state内容映射到组件上</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">29. 使用ES6创建react组件的方式是（class ...  extends</span> <a href="http://react.component/" style="font-size: 16pt;">React.Component</a><span style="font-size: 16pt;">）,ES5创建组件的方法是(React.createClass),创建无状态组件的方式是(function(props){return ()})</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">30. react中，ref属性的作用是（获取jsx中元素的真实dom节点或子组件）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">31. es5语法创建react组件比es6多了两个生命周期函数（getDefaultProps/getInitialState）</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">32. 请简述react-router中hashHistory和browserHistory的区别：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    这是react-router中设置监听url路径变化的两种方式，hashHistory在切换路由的时候会在url上跟着哈希值，browserHistory通过判断path变化才切换路由，且path变化的时候后端可以接收到请求，需要后端配置忽略掉</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">33. 请画图说明flux中的单向数据流</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    用户访问View-》view发出用户的action-》dispatcher收到action要求store进行更新-》store更改后，触发一个事件-》view接收到该事件的触发，更新页面</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">34. 简述react-redux的用法</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    创建store、reducer，通过provider将store传递给各个子组件，创建ui组件，生成容器组件，利用connect将store和容器组件连接</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">35. 说明redux设计和使用的三大原则：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    唯一数据源、保持状态只读、数据改变只能通过纯函数完成</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">36. 说明redux-thunk的使用方法：</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    npm install redux-thunk -S</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    //store</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    import {createStore,applyMiddleware} from 'redux'</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    import thunk from 'redux-thunk'</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    import reducer from './reducer'</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    const store  = createStore(reducer,applyMiddleware(thunk))</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    //actionCreator</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    const actionCreator = {</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        handlerChange(){</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            return (dispatch)=&gt;{</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">                ...</span></div><div style="margin-left: 40px;"></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">            }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">        }</span></div><div style="margin-left: 40px;"><span style="font-size: 16pt;">    }</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 